[{"title":"test","url":"/2018/12/04/test/"},{"title":"test_md","url":"/2018/12/04/test-md/"},{"title":"Hello World","url":"/2018/12/04/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n"},{"title":"正则符号","url":"/2018/03/13/正则符号/","content":"\n1.  【单个】描述某一个字符\n    -  x：表示由x所组成\n        ```java\n\t\t    System.out.println(\"a\".matches(\"a\"));\ttrue\n\t    \tSystem.out.println(\"aa\".matches(\"a\"));\tfalse\n        ```\t\t\n    - \\\\\\ 表一个 \\\n        ```java\n\t\tSystem.out.println(\"\\\\\".matches(\"\\\\\\\\\"));\ttrue\n        System.out.println(\"\\\\\".matches(\"\\\\\"));\tException\n        ```\n    * \\\\ 描述的一个 \\,\\\\\\\\描述的是\\\\，而\\\\在正则中表示一个\\ \n    - \\t：描述的是制表符\n    - \\n：表示换行\n\n2. 【单个】描述一个范围\n    - [abc]：可能是字母abc中的任意一个\n        ```java\n\t\tSystem.out.println(\"c\".matches(\"[abc]\"));\ttrue\n        System.out.println(\"x\".matches(\"[abc]\"));\tfalse\n        ```\n    - [^abc]：表示不是abc中的任意一个\n        ```java\n\t\tSystem.out.println(\"a\".matches(\"[^abc]\"));\tfalse\n        System.out.println(\"x\".matches(\"[^abc]\"));\ttrue\n        ``` \n    - [0-9]：“'0'~'9'”：由数字组成\n\n        ```java\n\t\tSystem.out.println(\"1\".matches(\"[0-9]\"));\ttrue\n        System.out.println(\"a\".matches(\"[0-9]\"));\tfalse\n        ```\n    - [a-zA-Z]：由字母组成，大小写任意\n        ```java\n\t\t\"a\".matches(\"[a-z]\")\ttrue\n\t\t\"A\".matches(\"[a-z]\")\tfalse\n\t\t\"a\".matches(\"[A-Z]\")\tfalse\n\t\t\"A\".matches(\"[A-Z]\")\ttrue\n\t\t\"a\".matches(\"[a-zA-Z]\")\ttrue\n        \"A\".matches(\"[a-zA-Z]\")\ttrue\n        ```\n3.  【单个】简化表达式：\n    - “.”：任意的一位字符\n        ```java\n\t\t\"a\".matches(\".\")\ttrue\n        \"ab\".matches(\".\")\tfalse\n        ```\n        - 注意：\n            ```java\n\t\t\t\".\".matches(\".\")\ttrue\n            \".\".matches(\"\\\\.\")\ttrue\n            ```\n            - 结果一样但含义不同\n    - \\d：等价于[0-9]，表示任意一位数字\n        ```java\n\t\t\"6\".matches(\"\\\\d\")\ttrue\n\t\t\"a\".matches(\"\\\\d\")\tfalse\n\t\t\ti. 注意\\\\表示\\\n        ``` \n    - \\D: 等价于[^0-9]\n        ```java\n\t\t\t\"6\".matches(\"[^0-9]\")\tfalse\n            \"a\".matches(\"[^0-9]\"\ttrue\n        ```\n        -    __注意“^”的位置在中括号里__\n\n    -  \\s：表示是一个空格或换行\n        ```java\n\t\t\"\\t\".matches(\"\\\\s\")\ttrue\n\t\t\" \".matches(\"\\\\s\")\ttrue\n        \"a\".matches(\"\\\\s\")\tfalse\n        ```\n    - \\S:   表示不是一个空格\n    - \\w：等价于“[a-zA-Z_]”，表示字母，数字下划线所组成\n    - \\W：等价于“[^a-zA-Z_]”\n4. 边界匹配（Java用不到）\n    - “^”正则的开始\n    - “&”正则的结束\n    ```java\n        ^[a-zA-Z_]&\n    ```\n    __在Java里就不要用了会出现问题，JavaScrip一定要用上__\n\n5. 数量表达式，在之前所有的符号只能编写几次就能够出现几次，如果现在需要重复n次就需要数量表达\n    - 正则?：表示该匹配出现一次或者零次\n        ```java\n\t\t\"a\".matches(\"\\\\w?\")\ttrue\n\t\t\"\".matches(\"\\\\w?\")\ttrue\n        \"aa\".matches(\"\\\\w?\")\tfalse\n        ```\n    - 正则+：表示该匹配出现一次或者多次\n        ```java\n\t\t\"\".matches(\"\\\\w+\")\tfalse\n\t\t\"a\".matches(\"\\\\w+\")\ttrue\n        \"aa\".matches(\"\\\\w+\")\t   true\n        ```\n    - 正则*：零次一次或多次\n        ```java\n\t\t\"\".matches(\"\\\\w*\")\ttrue\n\t\t\"a\".matches(\"\\\\w*\")\ttrue\n        \"aa\".matches(\"\\\\w*\")\ttrue\n        ```\n    - 正则{n}：该匹配必须出现n次\n        ```java\n\t\t\"\".matches(\"\\\\d{6}\")\tfalse\n\t\t\"1234\".matches(\"\\\\d{6}\"\tfalse\n        \"123456\".matches(\"\\\\d{6}\")\ttrue\n        ```\n    - 正则{n,}：该匹配刚好出现n次或n次以上\n        ```java\n\t\t\"1234\".matches(\"\\\\d{6,}\")\tfalse\n\t\t\"123456\".matches(\"\\\\d{6,}\")\ttrue\n        \"1234567\".matches(\"\\\\d{6,}\")\ttrue\n        ```\n    - {n,m}：表示出现n~m次\n        ```java\n\t\t\"1234567\".matches(\"\\\\d{6,9}\")\ttrue\n        \"1234567890\".matches(\"\\\\d{6,9}\"\tfalse\n        ```\n 6. 逻辑匹配\n    - 正则A正则B：表示与，一次匹配后立即匹配第二个\n\t- 正则A|正则B：表示A或B正则出现一次\n\t- (正则)：按照一组正则进行处理\n"},{"title":"简单排序二叉树(Java实现)","url":"/2018/03/08/简单排序二叉树-Java实现/","content":"## 代码实现 ##\n```java\npackage test;\n \nimport java.util.Arrays;\n \nclass BinaryTree{//实现二叉树\n\tprivate class Node{\n\t\tprivate Comparable data ; //保存的操作数据，因为必须是Comparable子类，而且需要判断大小\n\t\tprivate Node left;\n\t\tprivate Node right;\n\t\t@SuppressWarnings(\"unused\")\n\t\tpublic Node(Comparable data) {\n\t\t\tthis.data = data;\n\t\t}\n\t\tpublic void addNode(Node newNode) {\n\t\t\tif(this.data.compareTo(newNode.data)>0){\n\t\t\t\tif(this.left == null) {\n\t\t\t\t\tthis.left = newNode;\n\t\t\t\t}else {\n\t\t\t\t\tthis.left.addNode(newNode);\n\t\t\t\t}\n\t\t\t}else {\n\t\t\t\tif (this.right == null) {\n\t\t\t\t\tthis.right=newNode;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis.right.addNode(newNode);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpublic void toArrayNode() {\n\t\t\tif(this.left!=null){\n\t\t\t\tthis.left.toArrayNode();\n\t\t\t}\n\t\t\tBinaryTree.this.retData[BinaryTree.this.foot++]=this.data;\n\t\t\tif(this.right!=null) {\n\t\t\t\tthis.right.toArrayNode();\n\t\t\t}\n\t\t}\n\t}\n\t//--------------------------------------//\n\tprivate Node root;//任何数据结构一定要抓住根\n\tprivate int count;//保存个数\n\tint foot = 0;\n\tprivate Object [] retData;\n\tpublic Object [] toArrays(){\n\t\tthis.foot=0;\n\t\tthis.retData = new Object[this.count];\n\t\tthis.root.toArrayNode();\n\t\treturn this.retData;\n\t}\n\tpublic void add(Object data) {\n\t\t//可以保存任何数据\n\t\tif(data == null) {\n\t\t\treturn ;\n\t\t}\n\t\tNode newNode = new Node((Comparable) data);\n\t\tif(this.root == null) {\n\t\t\tthis.root=newNode;\n\t\t}else {\n\t\t\tthis.root.addNode(newNode);\n\t\t}\n\t\tthis.count++;\n\t}\n}\npublic class BTDemo {\n\tpublic static void main(String[] args) {\n\t\tBinaryTree bt = new BinaryTree();\n\t\tbt.add(\"B\");\n\t\tbt.add(\"X\");\n\t\tbt.add(\"F\");\n\t\tbt.add(\"A\");\n\t\tSystem.out.println(Arrays.toString(bt.toArrays()));\n\t}\n}\n\n```"},{"title":"还是一个测试","url":"/2018/03/07/还是一个测试/","content":"# 线程休眠\n## 所谓的线程休眠指的是，让线程暂缓执行，一下，等到了预计的时间之后再恢复执行\n### 方法：\n```java\n\tpublic static void sleep(long millis) throws InterruptedException\n```\n\t1) 使用毫秒作为单位。\n\t2) 中断异常\n### 范例\n```java\n\tclass MyThread implements Runnable {\n\t\t\t\t \n\t@Override\n\t public void run() {\n\t\t for(int x =0;x<2000;x++) {\n\t\t\ttry {\n\t\t\t\tThread.sleep(1000);\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t          // TODO Auto-generated catch block\n\t\t\t\t         e.printStackTrace();\n\t\t\t\t}\n\t\t\t\t System.out.println(Thread.currentThread().getName()+\"、x=\"+x);\n\t\t}\n\t\t\t\t \n\t}\n\t\t\t\t \n\t}\n\tpublic class mmmmmm {\n\t\t\t\t \n\t\tpublic static void main(String[] args) throws InterruptedException, ExecutionException {\n\t\t\t MyThread mt =new MyThread();\n\t\t\t new Thread(mt).start();\n\t\t\t new Thread(mt).start();\n\t\t\t new Thread(mt).start();\n\t\t\t\t \n\t\t\t}\n\t\t}\n```\n\t\t1) 会错误的认为三个线程是同时休眠的，千万要记住：所有的代码是依次进入run方法中的\n\t\t2) 真正进入到方法的对象可能是多个也可能是一个，所以所有进入代码的顺序延迟可能会有差异，但是总体的执行是并发执行。\n## 2. 线程的优先级\n### a. 优先级越高越有可能优先执行，但仅仅是有可能而已，再Thread类中有以下的优先级操作方法\n\t\ti. 设置优先级\n\t\t\tpublic final void setPriority(int newPriority)\n\t\t\tii. 取得优先级\n\t\t\tpublic final int getPriority()\n\t\tb. 对于优先级的设置内容可以通过Thread类的几个常量来决定\n\t\t\ti. 最高优先级\n\t\t\tpublic static final int MAX_PRIORITY、10\n\t\t\tii. 中等优先级\n\t\t\tpublic static final int NORM_PRIORITY、5\n\t\t\tiii. 最低优先级\n\t\t\tpublic static final int MIN_PRIORITY、1\n\t\tThread t1 = new Thread(mt,\"线程A\");\n\t\t        Thread t2 = new Thread(mt,\"线程B\");\n\t\t        Thread t3 = new Thread(mt,\"线程C\");\n\t\t        t1.setPriority(Thread.MIN_PRIORITY);\n\t\t        t1.start();\n\t\t        t2.start();\n\t\t        t3.start();\n\t\t·注意只是可能\n\t\tc. 主方法只是一个中等优先级\n"},{"title":"hexo部署个人博客","url":"/2018/03/07/hexo部署个人博客/","content":"这是一个测试"}]